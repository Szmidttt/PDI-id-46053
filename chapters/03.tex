\chapter{Migracja fragmentu kodu z języka programowania C++ na język Rust}
Niniejszy rozdział szczegółowo opisuje proces migracji wybranego komponentu z języka programowania C++ na język Rust. Zgodnie z założeniami projektu, poszukiwania odpowiedniego fragmentu kodu ograniczono do oprogramowania rozwijanego przez Fundację Mozilla, co w praktyce skierowało uwagę na bazę kodu przeglądarki Firefox. Główną motywacją dla podjętych działań jest dążenie do poprawy bezpieczeństwa pamięci i ogólnej stabilności aplikacji, co jest jednym ze strategicznych celów wykorzystania języka Rust w dojrzałych projektach. W dalszej części rozdziału przedstawiono kolejne etapy pracy: począwszy od kryteriów, które zadecydowały o wyborze komponentu, przez jego szczegółową analizę, aż po opis przyjętej strategii migracji, wykorzystanych narzędzi i finalnego przebiegu implementacji.
\section{Kryteria wyboru fragmetu kodu do migracji}
Podczas wyboru fragmentu kodu kierowaliśmy się kilkoma kluczowymi kryteriami:
\begin{itemize}
    \item \textbf{Wysoki potencjał poprawy bezpieczeństwa:}
    \begin {itemize}
        \item \textbf{Zarządzanie pamięcią:} Kandydat do migracji powinien operować w obszarze, w którym błędy zarządzania pamięcią, typowe dla języka C++, mogą prowadzić do poważnych luk w zabezpieczeniach. Przykładem może być praca z surowymi danymi, takimi jak zrzuty pamięci.
        \item \textbf{Zastąpienie przestarzałej zależności:} Komponent opiera się na zewnętrznej bibliotece C++, uznawanej za przestarzałą lub posiadającej nowocześniejszy i bezpieczniejszy odpowiednik w języku Rust.
    \end{itemize}
        \item \textbf{Wykonalność i modularność:} Fragment kodu musiał być na tyle odizolowany, aby jego migracja nie pociągała za sobą konieczności przepisywania znacznych części przeglądarki. Biblioteka o jasno zdefiniowanym API i konkretnym zadaniu ułatwia proces zastępowania implementacji bez naruszania reszty systemu.
        \item \textbf{Zgodność ze strategicznymi celami Fundacji Mozilla:} Wybrany komponent powinien wpisywać się w długofalową strategię Mozilli polegającą na stopniowym zwiększaniu ilości kodu napisanego w Rust w celu poprawy bezpieczeństwa i wydajności przeglądarki. Zgodnie z inicjatywą "Oxidation". \cite{oxidation}
    \end{itemize}
\section{Wybrany fragment kodu - biblioteka dynamiczna testcrasher}
Pierwszym etapem prac było zidentyfikowanie w kodzie źródłowym należącym do fundacji Mozilla odpowiedniego kandydata do migracji, który spełniałby wcześniej zdefiniowane kryteria. W procesie tym wykorzystano dwa narzędzia. Pierwszym z nich był Searchfox\cite{searchfox}, narzędzie które indeksuje kod źródłowy oraz umożliwia szybkie wyszukiwanie kodu i plików źródłowych. Drugim narzędziem była Bugzilla, system śledzenia zadań Mozilli, służący do zarządzania zgłoszeniami błędów, propozycjami zmian i zadaniami deweloperskimi.
Przy użyciu tych narzędzi oraz na podstawie powyżej opisanych kryteriów do migracji została wybrana wewnętrzna biblioteka testcrasher.dll. Na decyzję dodatkowo wpłynął fakt istnienia w systemie śledzenia błędów Mozilli zadania o numerze Bug 1798688\cite{bug1798688}, które jawnie definiuje cel jako "Replace breakpad with rust-minidump in the testcrasher library" \footnote{Zastąpienie breakpad przez rust-minidump w blibliotece testcrasher}.
\subsection{Cel biblioteki testcrasher}
Biblioteka dynamiczna testcrasher jest narzędziem deweloperskim które używane jest jako tester działania komponentu Crashreporter - wewnętrznego mechanizmu przeglądarki Firefox, odpowiedzialnego za zbieranie i raportowanie informacji o awariach aplikacji.
Działa poprzez wywoływanie awarii procesu a następnie analizę pliku zrzutu pamięci (.dmp) który został wytworzony przez moduł Crashreporter.
Jej działanie skupia się na dwóch obszarach:
\begin{itemize}
    \item \textbf{Analiza zrzutu pamięci:} Za tą część odpowiada plik dumputils.cpp. API tej części zawiera:
    \begin{itemize}
        \item \textbf{DumpHasStream()} - Zwraca wartość \texttt{true}, jeśli dany zrzut pamięci zawiera strumień określonego typu. 
        \item \textbf{DumpHasInstructionPointerMemory()} - Zwraca wartość \texttt{true}, jeśli dany zrzut pamięci zawiera region pamięci który zawiera wskaźnik instrukcji z rekordu wyjąktu.
        \item \textbf{DumpCheckMemory()} - Sprawdza, czy zrzut pamięci zawiera region rozpoczynający się pod adresem określonym w pliku \texttt{crash-addr} w bieżącym katalogu roboczym. Region ten musi mieć długość 32 bajtów i zawierać wartości od 0 do 31 w porządku rosnącym.
    \end{itemize}
    \item \textbf{Wywoływanie awarii procesu:} Za tą część odpowiada plik nsTestCrasher.cpp. API tej części zawiera:
    \begin{itemize}
        \item \textbf{Crash():} Funkcja pełniąca rolę głównego dyspozytora, odpowiedzialna za celowe wywołanie awarii procesu. Na podstawie przekazanego argumentu uruchamia odpowiednią implementację błędu.
        \item \textbf{EnablePHC():} Aktywuje mechanizm Probabilistic Heap Checker.
        \item \textbf{GetWin64CFITestFnAddrOffset():} Oblicza i zwraca relatywny adres wirtualny (RVA) funkcji asemblerowych służących do testów CFI (Control Flow Integrity), w odniesieniu do adresu bazowego biblioteki  testcrasher.dll.
        \item \textbf{TryOverrideExceptionHandler():} Rejestruje niestandardowy filtr wyjątków nieobsłużonych (poprzez API Windows \texttt{SetUnhandledExceptionFilter}), który wymusza natychmiastowe zakończenie procesu w momencie wystąpienia błędu.
        \item \textbf{SaveAppMemory():} Alokuje testowy bufor pamięci, wypełnia go określonym wzorcem danych, a następnie zapisuje jego adres do pliku \texttt{crash-addr}. Służy to weryfikacji, czy mechanizm raportowania awarii poprawnie dołącza wskazane, dodatkowe obszary pamięci aplikacji do wygenerowanego pliku zrzutu (minidump).
    \end{itemize}
\end{itemize}
\subsection{Architektura biblioteki testcrasher przed migracją}
Rdzeniem biblioteki dynamicznej testcrasher są dwa pliki źródłowe C++: dumputils.cpp i nsTestCrasher.cpp.
Moduł dumputils.cpp  wykorzystuje do swojego działania zewnętrzną bibliotekę Google Breakpad. Jest to projekt open-source napisany w C++, dostarczający API do obsługi plików minidump. Jednym z głównych zadań tej pracy jest pozbycie się tej zależności.
\\
Kod źródłowy biblioteki korzysta w niewielkim stopniu z kluczowych mechanizmów i konwencji specyficznych dla bazy kodu Firefoksa. Powoduje to że migracja kodu z Języka C++ na Język Rust nie będzie wiązać się z przepisywaniem/modyfikacjami kodu poza biblioteką testcrasher.
\\
System budowania Mozilli, w przypadku biblioteki testcrasher stosuje metodę gdzie pliki .cpp są łączone w jedną jednostkę kompilacji w celu przyspieszenia procesu. Następnie skompilowany kod obiektowy jest linkowany w ostateczną bibliotekę dynamiczną testcrasher.dll.
\\
Głównym sposobem użycia biblioteki są zautomatyzowane testy, najczęściej pisane w JavaScripcie i uruchamiane w specjalnym frameworku testowym Mozilli. Skrypt testowy wywołuje wyeksportowaną funkcję z testcrasher.dll w celu spowodowania awarii i sprawdzenia czy moduł Crash Reporter wygenerował poprawny plik zrzutu pamięci.
\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{figures/testcrasher.png}
\caption{Architektura biblioteki testcrasher - opracowanie własne}
\label{fig:testcrasher-architecture}
\end{figure}
\section{Strategia migracji i wykorzystane narzędzia}
Po wyborze biblioteki testcrasher jako fragmentu kodu do migracji na język Rust kolejnym ważnym aspektem był dobór odpowiedniej strategii oraz narzędzi.
Obrane podejście musiało uwzględniać specyfikę pracy z dużą bazę kodu jaką, jest projekt Mozilla Firefox. 
Priorytetem stało się zatem zapewnienie bezpieczeństwa samego procesu migracji, zdefiniowanego jako brak regresji - istniejące i działające funkcjonalności nie zostaną uszkodzone przez wprowadzane zmiany podczas procesu migracji oraz zachowanie stabilności binarnej (ABI zgodne z językiem C). Aby to osiągnąć, każda nowo napisana w Rust funkcja była natychmiast integrowana i weryfikowana za pomocą istniejącego zestawu testów automatycznych, co gwarantowało jej pełną kompatybilność z resztą systemu.
\subsection{Strategia migracji biblioteki testcrasher}
Przyjęta strategia migracji opiera się na stopniowym i iteracyjnym zastępowaniu kodu C++ kodem Rust, przy jednoczesnym zachowaniu w pełni kompatybilnego publicznego API.
Fundamentalnym założeniem jest, że z perspektywy klienta biblioteki, którym w tym przypadku są skrypty testujące, proces migracji jest całkowicie niewidoczny. Wymaga to utrzymania stabilnego interfejsu binarnego aplikacji (ABI) zgodnego z językiem C. Dzięki temu poszczególne funkcje, a docelowo całe moduły zaimplementowane w C++, mogą być zastępowane ich odpowiednikami w Rust, a następnie weryfikowane za pomocą istniejącego zestawu testów.
Proces migracji został zaplanowany w następujących, logicznie następujących po sobie etapach:
\begin{enumerate}
    \item \textbf{Konfiguracja procesu budowania:} Pierwszym krokiem jest modyfikacja systemu budowania Mozilli (moz.build) w celu umożliwienia współistnienia kodu C++ i Rust. Polega to na zdefiniowaniu reguł kompilacji dla nowego kodu Rust do postaci biblioteki statycznej (rust\_testcrasher.lib). Następnie, ta biblioteka statyczna jest dołączana do finalnej biblioteki dynamicznej (testcrasher.dll), a jej publiczne symbole są eksportowane w taki sposób, aby zachować zgodność z oryginalnym API.
    \item \textbf{Iteracyjna migracja logiki analitycznej (dumputils.cpp):} Proces właściwej migracji rozpoczyna się od komponentów analitycznych. Poszczególne funkcje odpowiedzialne za parsowanie i analizę plików minidump są reimplementowane w języku Rust, wykorzystując do tego celu crate rust-minidump. Po zaimplementowaniu każdej funkcji w Rust, jej oryginalna wersja w C++ jest usuwana, a nowa implementacja zostaje zintegrowana w procesie budowania.
    \item \textbf{Migracja logiki inicjującej awarie (nsTestCrasher.cpp):} Po pomyślnej weryfikacji poprawności działania modułu analitycznego, analogiczny proces jest stosowany do kodu odpowiedzialnego za inicjowanie stanów awaryjnych. Funkcje C++ są zastępowane przez ich odpowiedniki w Rust, które wykorzystują bibliotekę sadness-generator.
    \item \textbf{Finalizacja i czyszczenie konfiguracji:} Po zakończeniu migracji całości kodu funkcjonalnego do języka Rust, oryginalne pliki źródłowe C++ (dumputils.cpp oraz nsTestCrasher.cpp) są ostatecznie usuwane z drzewa projektu. Konfiguracja w pliku moz.build jest upraszczana, eliminując reguły dotyczące kompilacji C++ dla tej biblioteki.
\end{enumerate}
Dzięki takiemu podejściu, w dowolnym momencie procesu migracji biblioteka pozostaje w pełni funkcjonalna, zawierając mieszankę działającego kodu C++ i Rust.
\subsection{Wykorzytane narzędzia i technologie}
Do przeprowadzenia migracji wybranego fragmentu kodu użyto następujących narzędzi i technologi:
\begin{itemize}
    \item \textbf{Języki programowania i platforma:}
    \begin{itemize}
        \item Rust (v1.91)
        \item C++ (Standard C++17)
        \item Python 3.12
        \item Windows 10 Pro 22H2 64-bit
    \end{itemize}
    \item \textbf{Środowisko i system budowania:}
    \begin{itemize}
        \item \textbf{mach:} Narzędzie wiersza poleceń (CLI) stworzone przez fundacje Mozilla w celu wspomagania rozwoju przeglądarki Firefox, zaimplementowane w języku Python. Pełni ono funkcję generycznego dyspozytora poleceń. W pracy głównym użyciem było uruchamianie budowania biblioteki oraz uruchamiane testów.
        \item \textbf{WSL (Windows Subsystem for Linux):} Wirtualne środowisko wykorzystane pomocniczo do procesu vendorowania bibliotek Rust. Jego użycie było konieczne z powodu na niestabilność mechanizmu pobierania zależności na Windowsie.
    \end{itemize}
    \item \textbf{Narzędzia umożliwiajęce interoperacyjność:}
    \begin{itemize}
        \item \textbf{Bindgen-cli (v0.72.1):} Narzędzie wiersza poleceń służące do automatycznego generowania wiązań (ang. \textit{bindings}) dla języka Rust na podstawie nagłówków C++. Zdecydowano się na statyczne wygenerowanie plików zamiast generowania ich w czasie kompilacji. Jest to zgodne z praktyką stosowaną w projekcie Firefox\cite{rust-integration}. Podejście to jest rekomendowane w sytuacjach, gdy natywne API jest stabilne, co pozwala uniknąć niepotrzebnego wydłużania czasu kompilacji projektu.
    \end{itemize}
    \item \textbf{Biblioteki Rust(Crate):}
    \begin{itemize}
        \item \textbf{rust-minidump v(0.24):} Kolekcja bibliotek służąca do odczytu i analizy plików zrzutu pamięci, modelowana na podstawie Google Breakpad\cite{rust-minidump}. W celu przeprowadzenia migracji użyta została biblioteka minidump-processor.
        \item \textbf{sadness-generator (v0.6):} Crate zawierający implementacje kodu wywołującego awarie procesu. Użyty został zgodnie z sugestią zgłaszającego bug 1798688. W praktyce jednak ze względu na specyficzne dla ekosystemu Mozilli mechanizmy obsługi błędów i zarządzania pamięcią, wykorzystanie tej biblioteki zostało ograniczone jedynie do standardowych scenariuszy awarii.
        \item \textbf{windows-sys (v0.52):} Niskopoziomowa biblioteka dostarczająca surowe deklaracje funkcji (FFI), struktur i stałych API systemu Windows, bez dodatkowych warstw abstrakcji. Jej wybór podyktowany był koniecznością bezpośredniego wywoływania funkcji systemowych, co umożliwiło implementację scenariuszy awarii specyficznych dla platformy Windows.
        \textbf{libc (v0.2):} Biblioteka zapewniająca bezpośredni dostęp do standardowych funkcji języka C (np. \texttt{malloc}, \texttt{free}). Jej użycie było kluczowe przy migracji testów mechanizmu PHC (Probabilistic Heap Checker), gdzie wymagana była surowa alokacja i zwalnianie pamięci z pominięciem bezpiecznych abstrakcji alokatora języka Rust.
    \end{itemize}
    \item \textbf{Narzędzia analityczne i inżynieria wsteczna:}
    \begin{itemize}
        \item \textbf{Searchfox:} Narzędzie do semantycznego indeksowania i przeszukiwania kodu źródłowego Mozilli. Wykorzystane do analizy migrowanego kodu oraz identyfikacji miejsc wywołań biblioteki w projekcie. Umożliwiło również poznanie obowiązującego stylu kodowania oraz adaptację istniejących wzorców projektowych.
        \item \textbf{Bugzilla:} System śledzenia błędów pełniący rolę głównego rejestru zadań (ang. \textit{issue tracker}) w organizacji Mozilla. Posłużył do znalezienia fragmentu kodu do migracji oraz analizy wymagań funkcjonalnych.
    \end{itemize}
\end{itemize}
\section{Migracja części odpowiedzialnej za analizę zrzutów pamięci}
Proces migracji komponentu odpowiedzialnego za analizę zrzutów pamięci, zaimplementowanego pierwotnie w pliku dumputils.cpp, rozpoczęto od przygotowania środowiska deweloperskiego. Celem było umożliwienie kompilacji kodu Rust i jego integracji z istniejącą, opartą na C++, strukturą biblioteki testcrasher.
\subsection{Przygotowanie środowiska}
Integracja nowego kodu w języku Rust z rozbudowanym ekosystemem przeglądarki Firefox wymagała przeprowadzenia kilku operacji konfiguracyjnych w systemie budowania.

Pierwszym krokiem było zdefiniowanie nowego crate - podstawowej jednostki kompilacji i dystrybucji w ekosystemie Rust. W katalogu komponentu utworzono podkatalog rust w ktorym umieszczono trzy pliki:
\begin{itemize}
\item \textbf{Cargo.toml} - manifest pakietu, definiujący jego metadane (nazwę, wersję, edycję języka "2021") oraz zależności. Skonfigurowano go tak, aby generował bibliotekę statyczną crate-type = ["staticlib"], co jest niezbędne do późniejszego linkowania z kodem C++.
\item \textbf{lib.rs} - punkt wejścia do biblioteki, początkowo zawierający jedynie szkielet modułu.
\item \textbf{moz.build} - plik systemu budowania Mozilli umożliwiający kompilację kodu Rust zgodnie z manifestem pakietu.
\end{itemize}
W tym crate docelowo ma znaleźć się cała nowa implementacja funkcjonalności biblioteki testcrasher.

Następnie, nowo utworzony crate musiał zostać włączony do głównego workspace projektu Firefox. Workspace w kontekście narzędzia Cargo (menedżera pakietów Rust) to zbiór crate'ów, które są zarządzane i kompilowane wspólnie. Dodanie testcrasher do tej struktury formalnie uczyniło go częścią przeglądarki.

Kolejnym krokiem było zsynchronizowanie zależności dla całego projektu. Wykonano to za pomocą polecenia \texttt{cargo update -p workspace-hack}. Polecenie to aktualizuje plik Cargo.lock dla całego workspace, zapewniając spójność wersji wszystkich zależności i umożliwiając systemowi budowania poprawne przetwarzanie nowego komponentu.

Ostatnim, etapem było zmodyfikowanie pliku konfiguracyjnego systemu budowania - moz.build w folderze testcrasher oraz dodanie nowego pliku moz.build w folderze zawierającym kod źródłowy Rust. Pliki moz.build, są skryptami w języku Python, jednak ich działanie jest określone poprzez specjalne zasady określone przez Mozille. Ich celem jest określienie funkcjonalności plików w folderze w którym się znajdują\cite{mozbuild}. W przypadku biblioteki testcrasher plik moz.build po modyfikacjach wyglądał następująco:
\input{code_frags/moz.build/1.tex}
Modyfikacje dokonane w pliku moz.build umożliwiają współistnienie kodu C++ oraz Rust w ramach finalnej biblioteki testcrasher.dll. Konfiguracja ta instruuje system budowania, aby dołączył rust\_testcrasher.lib - bibliotekę statyczną zawierającą skompilowany kod Rust do finalnej biblioteki testcrasher.dll. Istotnym elementem przyjętej strategii było tymczasowe zachowanie pliku dumputils.cpp oraz zależności od Google Breakpad. Takie podejście umożliwiło stopniowe przepisywanie funkcjonalności oraz weryfikację stabilności rozwiązania poprzez testy funkcjonalne po każdej zmianie.
Szczegółowa lista zmian wraz z ich celem znajduje się w tabeli \ref{tab:mozbuild-1}.
\input{tables/03_mozbuild-mods.tex}
\subsection{Omówienie migracji części odpowiedzialnej za analizę w języku Rust}
W niniejszym podrozdziale przedstawiono i przeanalizowano kluczowe zmiany wynikające z migracji kodu z C++ na Rust. 
\subsubsection{Zastąpienie zależności i nowy model obsługi błędów}
\begin{itemize}
    \item Kod w C++:
    \input{code_frags/cpp/1.tex}
    \item Kod w Rust:
    \input{code_frags/rust/1.tex}
\end{itemize}
W wersji C++ funkcja dump.Read() zwraca wartość logiczną, a metody GetException() i GetMemoryList() zwracają surowe wskaźniki. Programista jest odpowiedzialny za ręczne sprawdzanie wartości false lub wskaźnika nullptr po każdej operacji. Pominięcie takiego sprawdzenia może prowadzić do niezdefiniowanego zachowania lub awarii programu.
Wersja w Ruście wykorzystuje typ Result, który jest typem wyliczeniowym (enum) mogącym przyjąć jeden z dwóch wariantów: Ok(wartość) w przypadku sukcesu lub Err(błąd) w przypadku porażki. Użycie konstrukcji match zmusza programistę do jawnego obsłużenia obu scenariuszy już na etapie kompilacji. Eliminuje to całą klasę błędów polegających na zignorowaniu niepowodzenia operacji. Kompilator Rusta nie pozwoliłby na użycie zmiennej dump lub exception bez uprzedniego "rozpakowania" \space jej z wariantu Ok.
\subsubsection{Bezpieczeństwo Pamięci}
Kod w C++ operuje na surowych wskaźnikach const char* przekazywanych z zewnątrz. Rust, mimo że również musi obsłużyć te wskaźniki w interfejsie FFI (Foreign Function Interface), natychmiast opakowuje je w bezpieczne abstrakcje.
\begin{itemize}
    \item Kod w C++:
    \input{code_frags/cpp/2.tex}
    \item Kod w Rust:
    \input{code_frags/rust/2.tex}
\end{itemize}
W C++ const char* nie przechowuje informacji o swojej długości i jest podatny na błędy odczytu poza alokowaną pamięcią. W Ruście surowy wskaźnik *const c\_char jest natychmiast konwertowany na bezpieczny typ \&CStr. Co istotne, operacja ta jest zamknięta w bloku unsafe, co jasno sygnalizuje miejsce, gdzie programista bierze na siebie odpowiedzialność za poprawność wskaźnika. Zaraz po tym następuje próba konwersji do bezpiecznego, zarządzanego przez Rusta typu \&str, która dodatkowo weryfikuje poprawność kodowania UTF-8. Cały pozostały kod funkcji operuje już na bezpiecznych typach, minimalizując powierzchnię ataku.
\subsubsection{Operacje plikowe i parsowanie}
W funkcji DumpCheckMemory widoczna jest znacząca różnica w sposobie obsługi operacji wejścia/wyjścia oraz parsowania danych
\begin{itemize}
    \item Kod w C++:
    \input{code_frags/cpp/3.tex}
    \item Kod w Rust:
    \input{code_frags/rust/3.tex}
\end{itemize}
Podejście z C++ jest niskopoziomowe i podatne na błędy. Programista musi ręcznie zarządzać uchwytem do pliku (FILE*), pamiętając o jego zamknięciu (fclose) w każdej możliwej ścieżce wyjścia z funkcji. Biblioteka standardowa Rusta oferuje znacznie bezpieczniejsze abstrakcje. Funkcja fs::read\_to\_string w jednej operacji otwiera plik, odczytuje całą jego zawartość do String i automatycznie go zamyka, a wynik zwraca jako Result. Parsowanie jest również jawne i bezpieczne: u64::from\_str\_radix wymaga podania podstawy systemu liczbowego (tutaj 16) i również zwraca Result, co chroni przed niepoprawnym formatem danych w pliku. Takie podejście jest nie tylko bezpieczniejsze, ale również czytelniejsze.
\subsection{Architektura po migracji modułu analitycznego}
W tym kroku, po pomyślnej reimplementacji logiki analizy zrzutów pamięci, możliwe stało się całkowite wyeliminowanie zależności od biblioteki Google Breakpad oraz usunięcie pliku źródłowego dumputils.cpp. Funkcjonalność ta została w pełni przejęta przez kod w języku Rust. Uproszczoną strukturę biblioteki, pozbawioną już komponentów analitycznych napisanych w C++, przedstawiono na schemacie blokowym \ref{fig:testcrasher-architecture2}. Widać na nim, że plik moz.build nie odwołuje się już do źródeł Breakpada, a jedynie do biblioteki rust\_testcrasher oraz pozostawionego jeszcze pliku nsTestCrasher.cpp.
\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{figures/testcrasher2.png}
\caption{Architektura biblioteki testcrasher - Etap 2 - opracowanie własne}
\label{fig:testcrasher-architecture2}
\end{figure}
\section{Migracja fragmentu odpowiedzialnego za wywoływanie awarii procesu}
Kolejny etap prac obejmował migrację fragmentu kodu którego zadaniem było wywoływanie awarii procesu, logika za to odpowiedzialna orginalnie była zaimplementowana z pliku nsTestCrasher.cpp.
Ta część migracji w odróżnieniu od poprzedniej nie zakłada zastąpienia zależności napisanej w języku C++.
Podobnie jak w poprzednim etapie migracji trzeba było rozpocząć od przygotowania systemu budowania Mozilli.
\subsection{Przygotowanie środowiska}%TODO
Prace nad migracją fragmentu wymagały zmian w konfiguracji zarówno pliku systemu budowania moz.build oraz w pliku manifestu pakietu Cargo.toml. Głównym celem było dodanie nowej zależności do projektu Mozilla jakią był crate sadness-generator który zapewniał implementacje niektórych awarii procesu.
\subsubsection{Dodanie zależności i proces weryfikacji}
\label{sec:implementacja_awarii}
Procedura dodania biblioteki sadness-generator przebiegała dwuetapowo:
\begin{enumerate}
\item \textbf{Deklaracja wersji:} Pierwszym krokiem była modyfikacja pliku Cargo.toml w katalogu komponentu. W przypadku bibliotek, które już znajdują się w drzewie projektu, wystarczy wskazać ich wersję.
\item \textbf{Vendorowanie (Vendor-ing):} Ponieważ sadness-generator był nową zależnością, nieobecną w repozytorium, konieczne było pobranie jej kodu źródłowego i dołączenie go do projektu. Służy do tego polecenie:
\begin{verbatim}
./mach vendor rust
\end{verbatim}
\end{enumerate}

Podczas realizacji tego kroku napotkano istotne wyzwanie związane ze środowiskiem pracy. Komenda \texttt{mach vendor rust} wykazywała niestabilność na systemie Windows, co jest znanym problemem w systemie śledzenia błędów Bugzilla\cite{bug1938341}. Aby kontynuować prace, proces vendorowania przeprowadzono w środowisku WSL (Windows Subsystem for Linux), co pozwoliło na poprawne pobranie źródeł.
\subsubsection{Flaga MOZ\_PHC}
Istotnym wyzwaniem była synchronizacja ustawień kompilacji między systemem budowania Mozilli a Cargo. Mechanizm PHC (Probabilistic Heap Checker) jest opcjonalny i włączany globalną flagą MOZ\_PHC. Kod w Rust nie ma jednak bezpośredniego dostępu do zmiennych środowiskowych procesu budowania.
Aby rozwiązać ten problem, zastosowano mechanizm Rust features. W pliku moz.build dodano logikę, która sprawdza globalną konfigurację i warunkowo aktywuje odpowiednią flagę dla kompilatora Rust:
\input{code_frags/cargo.toml/moz_phc.tex}
\input{code_frags/moz.build/moz_phc.tex}
Dzięki temu zabiegowi, w kodzie źródłowym Rust możliwe stało się użycie atrybutu \texttt{\#[cfg(feature = "moz\_phc")]}, aby warunkowo kompilować fragmenty kodu odpowiedzialne za współpracę z PHC, tylko wtedy, gdy mechanizm ten jest aktywny w przeglądarce.
\subsubsection{Przygotowanie warstwy pośredniczącej (FFI)}
Dodatkowo w tym przypadku niemożliwe było przeprowadzenie kompletnej migracji na język Rust. Spowodowane było to faktem że wiele fundamentalnych funkcji, takich jak makro \texttt{MOZ\_CRASH()} (służące do bezpiecznego przerywania działania programu w krytycznych momentach), jest zaimplementowanych jako makra preprocesora C++ lub funkcje \texttt{inline}. Język Rust, komunikując się poprzez interfejs FFI (Foreign Function Interface), może łączyć się jedynie z istniejącymi symbolami, a nie z dyrektywami preprocesora, które znikają po etapie kompilacji C++.
W związku z tym, aby zmapować mechanizm \texttt{panic!()} w Rust na systemowe wywołanie awarii w Firefoxie, konieczne było zastosowanie wzorca projektowego Shim (adaptera). Stworzono dedykowaną warstwę kodu łączącego, umożliwia wykorzystanie kodu C++ przez kod w Rust. W tym celu utworzono dwa pliki:
\begin{itemize}
    \item \textbf{wrapper.h} - uproszczony plik nagłówkowy, przygotowany specjalnie dla narzędzia bindgen. Zdefiniowano w nim tylko te typy i funkcje, które są niezbędne dla Rusta, ukrywając resztę złożoności nagłówków C++.
    \item \input{code_frags/h/wrapper.tex}
    \item \textbf{wrapper.cpp} -  plik implementacyjny, który pełni dwie funkcje:
    \begin{enumerate}
        \item Udostępnia funkcje pośredniczące (wrappery) do mechanizmów Mozilli, np. \texttt{Rust\_moz\_xmalloc} czy \texttt{Rust\_SetPHCState}.
        \item Implementuje specyficzne dla C++ scenariusze błędów, niemożliwe do pełnego odwzorowania w Rust (np. funkcja \texttt{PureVirtualCall} wywołująca błąd czystej funkcji wirtualnej).
    \end{enumerate}
    \input{code_frags/cpp/wrapper.tex}
\end{itemize}
Takie podejście zapewniło czystą separację i pozwoliło uniknąć błędów kompilacji, które pojawiały się przy próbie bezpośredniego parsowania pełnych nagłówków silnika Gecko przez narzędzie bindgen. 
Rezultatem wykonania komendy \texttt{bindgen} był plik bindings.rs, który zawierał interfejs programistyczny (API) zrozumiany dla kompilatora Rust.
Należy jednak podkreślić, że plik ten nie zawierał faktycznej implementacji (ciał funkcji), a jedynie ich deklaracje zamknięte w blokach \texttt{extern "C"}. Z perspektywy języka Rust są to tzw. symbole zewnętrzne - obietnica, że kod maszynowy tych funkcji zostanie dostarczony później. Fizyczne powiązanie tych deklaracji z ich wykonawczymi odpowiednikami (zaimplementowanymi w wrapper.cpp) następuje dopiero w fazie linkowania. Wówczas linker łączy skompilowany kod Rusta ze skompilowanym obiektem C++, rozwiązując puste symbole i tworząc działającą bibliotekę.
Wygenerowany fragment pliku bindings.rs przedstawiono na listingu poniżej:
\input{code_frags/rust/bindings.tex}
\subsection{Omówienie migracji części odpowiedzialnej za wywołanie awarii procesu w języku Rust}
W niniejszym podrozdziale przedstawiono i przeanalizowano kluczowe zmiany wynikające z migracji logiki odpowiedzialnej za wywoływanie awarii procesu z pliku nsTestCrasher.cpp na język Rust. Migracja ta wymagała zastosowania innego podejścia niż w przypadku modułu analitycznego, ze względu na konieczność integracji z niskopoziomowymi mechanizmami systemu operacyjnego oraz specyficznymi konstrukcjami języka C++.
\subsubsection{Struktura dyspozytora awarii}
Główna funkcja \texttt{Crash()} pełni rolę dyspozytora, który na podstawie przekazanego argumentu wywołuje odpowiedni scenariusz błędu. Porównanie implementacji w obu językach ukazuje fundamentalne różnice w sposobie obsługi wielowariantowej logiki.
\begin{itemize}
    \item Kod w C++:
    \input{code_frags/cpp/crasher_switch.tex}
    \item Kod w Rust:
    \input{code_frags/rust/crasher_match.tex}
\end{itemize}
W wersji C++ wykorzystano tradycyjną instrukcję \texttt{switch-case}, która wymaga jawnego użycia słowa kluczowego \texttt{break} po każdym przypadku. W języku Rust konstrukcja \texttt{match} jest wyrażeniem, które wymusza pełne pokrycie wszystkich możliwych wariantów. Kompilator zgłasza błąd, jeśli programista nie obsłuży wszystkich przypadków. Dodatkowo, każde ramię konstrukcji match jest izolowane i nie występuje problem przepływu, jak w przypadku C++ przy pominięciu \texttt{break}.
Istotną różnicą jest również wykorzystanie biblioteki \texttt{sadness-generator} do implementacji standardowych scenariuszy awarii. Zamiast ręcznie konstruować wskaźniki jak w C++ (\texttt{volatile int* foo = (int*)0x42}), Rust wykorzystuje abstrakcję \texttt{SadnessFlavor::Segfault.make\_sad()}, która jest bezpieczniejsza i bardziej czytelna.
\subsubsection{Zarządzanie pamięcią w funkcji SaveAppMemory}
Funkcja \texttt{SaveAppMemory()} demonstruje fundamentalną różnicę w podejściu do zarządzania pamięcią między C++ a Rust. Jej zadaniem jest alokacja bufora, wypełnienie go danymi testowymi i zapisanie adresu do pliku.
\begin{itemize}
    \item Kod w C++:
    \input{code_frags/cpp/save_app_memory.tex}
    \item Kod w Rust:
    \input{code_frags/rust/save_app_memory.tex}
\end{itemize}
W C++ bufor \texttt{testData} jest zmienną globalną o statycznym czasie życia, co oznacza że pamięć jest alokowana na etapie kompilacji i istnieje przez cały czas działania programu. Podejście to jest proste, ale wprowadza stan mutowalny, który może być źródłem błędów.

Wersja w Rust wykorzystuje mechanizm \texttt{Box::leak()}, który celowo "wycieka" pamięć, tworząc referencję o statycznym czasie życia. Pamięć musi przetrwać do momentu awarii procesu, aby moduł Crashreporter mógł ją odczytać. Użycie \texttt{Box::leak()} jest jawną deklaracją, w przeciwieństwie do globalnego stanu w C++.
w Rust nie ma zmiennych globalnych o statycznym czasie życia, które można mutować bezpiecznie (poza \texttt{static mut}, ale jest to niezalecane i niebezpieczne).
Dodatkowo, zamiast C++ funkcji \texttt{fopen/fprintf/fclose} z ręcznym sprawdzaniem błędów, w języku Rust zastosowano \texttt{fs::File::create()} z konstrukcją \texttt{if let Ok(...)}, która obsługuje potencjalne błędy.
\subsubsection{Kompilacja warunkowa i mechanizm PHC}
Migracja kodu związanego z mechanizmem PHC wymagała zastosowania odpowiedników dyrektyw preprocesora C++ w języku Rust.
\begin{itemize}
    \item Kod w C++:
    \input{code_frags/cpp/phc_allocation.tex}
    \item Kod w Rust:
    \input{code_frags/rust/phc_allocation.tex}
\end{itemize}
Kod Rust korzysta z funkcji biblioteki \texttt{libc} (\texttt{malloc} i \texttt{free}) zamiast bezpiecznych alokatorów Rust. Jest to konieczne, ponieważ mechanizm PHC wymaga bezpośredniego dostępu do alokacji pamięci w sposób, który może być monitorowany przez moduł PHC. Użycie standardowych abstrakcji Rust (np. \texttt{Vec} lub \texttt{Box}) uniemożliwiło poprawne działanie testów i wymagało dodatkowych zmian w całym projekcie, które nie wchodzą w zakres niniejszej pracy.
\subsubsection{Integracja z Windows API}
Obsługa niskopoziomowych mechanizmów systemu Windows, takich jak rejestracja niestandardowego filtru wyjątków, wymagała precyzyjnego odwzorowania API systemu operacyjnego.
\begin{itemize}
    \item Kod w C++:
    \input{code_frags/cpp/exception_handler.tex}
    \item Kod w Rust:
    \input{code_frags/rust/exception_handler.tex}
\end{itemize}
W C++ integracja z Windows API jest bezpośrednia i wystarczy dołączyć odpowiedni nagłówek (\texttt{<windows.h>}), zatem wywołać funkcje systemowe. Konwencja wywołania (\texttt{WINAPI}) i typy (np. \texttt{LONG}, \texttt{EXCEPTION\_POINTERS*}) są natywnie obsługiwane.

W Rust konieczne było użycie biblioteki \texttt{windows-sys}, która dostarcza niskopoziomowe wiązania do Windows API. Funkcja obsługująca wyjątki musi być oznaczona konwencją wywołania \texttt{extern "system"}, która na platformie Windows odpowiada konwencji \texttt{stdcall}. Atrybut \texttt{\#[cfg(target\_os = "windows")]} zapewnia, że kod jest kompilowany wyłącznie na platformie docelowej.
\subsubsection{Obsługa testów CFI na architekturze x86\_64}
Następnym wyzwaniem była migracja logiki odpowiedzialnej za testy CFI, które wymagają bezpośredniej interakcji z kodem asemblerowym.
\input{code_frags/rust/cfi_resolve.tex}
Funkcje testowe CFI są zaimplementowane w języku asemblera (plik \texttt{win64UnwindInfoTests.asm}) i nie podlegały migracji. Zadaniem kodu Rust było jedynie zapewnienie interfejsu do ich wywoływania. W tym celu zdefiniowano blok \texttt{extern "C"} z deklaracjami funkcji zewnętrznych oraz funkcję pomocniczą \texttt{resolve\_cfi\_func\_addr()}, która mapuje identyfikatory na wskaźniki do funkcji asemblerowych.

Warto zwrócić uwagę na wyjaśniający komentarz w kodzie: funkcje asemblerowe zwracają adresy wskazujące na tablicę skoków, nie na właściwe ciała funkcji. Aby uzyskać poprawny wskaźnik, należy wywołać funkcję z argumentem \texttt{returnpfn=1}. Ten mechanizm został zachowany bez zmian z oryginalnej implementacji C++.
\subsection{Architektura po migracji}
Po zakończeniu procesu migracji obu modułów(analitycznego (dumputils.cpp) oraz odpowiedzialnego za wywoływanie awarii (nsTestCrasher.cpp)), architektura biblioteki testcrasher uległa znacznej zmianie. Całość logiki funkcjonalnej została przeniesiona do kodu napisanego w języku Rust, eliminując zależność od biblioteki Google Breakpad oraz znaczną część oryginalnego kodu C++.
Mimo przeprowadzenia migracji, pewne elementy pozostały zaimplementowane w języku oryginalnym:
\begin{itemize}
    \item \textbf{wrapper.cpp} - warstwa pośrednicząca zapewniająca dostęp do mechanizmów niedostępnych bezpośrednio w języku Rust (makro \texttt{MOZ\_CRASH()}, funkcje PHC, alokator \texttt{moz\_xmalloc}).
    \item \textbf{ExceptionThrower.cpp} - kod odpowiedzialny za generowanie wyjątków C++, które nie mogą być w pełni odwzorowane w Rust.
    \item \textbf{win64UnwindInfoTests.asm} - kod asemblerowy testów CFI.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{figures/testcrasher3.png}
    \caption{Architektura biblioteki testcrasher - Etap 3 - opracowanie własne}
    \label{fig:testcrasher-architecture-final}
\end{figure}
Końcowa architektura charakteryzuje się następująco:
\begin{enumerate}
    \item \textbf{Warstwa API (Rust):} Funkcje eksportowane (\texttt{Crash()}, \texttt{SaveAppMemory()}, \texttt{DumpHasStream()} itd.) są zaimplementowane w Rust i stanowią publiczny interfejs biblioteki.
    \item \textbf{Warstwa pośrednicząca (C++):} Plik \texttt{wrapper.cpp} dostarcza funkcje pomocnicze (\texttt{Rust\_moz\_xmalloc()}, \texttt{Rust\_MOZ\_CRASH()}) wywoływane z kodu Rust poprzez FFI.
    \item \textbf{Zależności zewnętrzne:} Biblioteka \texttt{rust-minidump} zastąpiła Google Breakpad do analizy plików zrzutu pamięci, a \texttt{sadness-generator} dostarcza implementacje standardowych scenariuszy awarii.
\end{enumerate}

\subsubsection{Proces budowania}
Proces budowania biblioteki został rozszerzony o etap kompilacji kodu Rust:
\begin{enumerate}
    \item \textbf{Kompilacja Rust:} System budowania Mozilla (\texttt{mach}) wywołuje Cargo, który kompiluje kod źródłowy Rust do biblioteki statycznej \texttt{rust\_testcrasher.lib}.
    \item \textbf{Kompilacja C++:} Pliki \texttt{wrapper.cpp}, \texttt{ExceptionThrower.cpp} oraz opcjonalnie \texttt{win64UnwindInfoTests.asm} są kompilowane do obiektów.
    \item \textbf{Linkowanie:} Wszystkie komponenty są łączone w finalną bibliotekę dynamiczną \texttt{testcrasher.dll}. Symbole zdefiniowane w pliku \texttt{testcrasher.def} są eksportowane jako API.
\end{enumerate}
