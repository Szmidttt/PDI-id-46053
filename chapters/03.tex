
\chapter{Migracja fragmentu kodu z języka programowania C++ na język Rust}
\section{Wybór fragmetu kodu do migracji}
Podczas wyboru fragmentu kodu kierowaliśmy się kilkoma kluczowymi kryteriami:
\begin{itemize}
    \item \textbf{Wysoki potencjał poprawy bezpieczeństwa:}
    \begin {itemize}
        \item \textbf{Zarządznie pamięcią:} Kandydat do migracji powinien operować w obszarze, w którym błędy zarządzania pamięcią, typowe dla języka C++, mogą prowadzić do poważnych luk w zabezpieczeniach. Przykładem może być praca z surowymi danymi, takimi jak zrzuty pamięci.
        \item \textbf{Zastąpienie przestarzałej zależności:} Komponent opiera się na zewnętrznej bibliotece C++, uznawanej za przestarzałą lub posiadającej nowocześniejszy i bezpieczniejszy odpowiednik w języku Rust.
    \end{itemize}
        \item \textbf{Wykonalność i modularność:} Fragment kodu musiał być na tyle odizolowany, aby jego migracja nie pociągała za sobą konieczności przepisywania znacznych części przeglądarki. Biblioteka o jasno zdefiniowanym API i konkretnym zadaniu ułatwia proces zastępowania implementacji bez naruszania reszty systemu.
        \item \textbf{Zgodność ze strategicznymi celami Fundacji Mozilla:} Wybrany komponent powinien wpisywać się w długofalową strategię Mozilli polegającą na stopniowym zwiększaniu ilości kodu napisanego w Rust w celu poprawy bezpieczeństwa i wydajności przeglądarki. Zgodnie z incjatywą "Oxidation". \cite{oxidation}
    \end{itemize}
Na podstawie tych cech do migracji została wybrana wewnętrzna biblioteka testcrasher.dll. Na decyzję dodatkowo wpłyną fakt istnienia w systemie śledzenia błędów Mozilli zadania o numerze Bug 1798688\cite{bug1798688}, które jawnie definiuje cel jako "Replace breakpad with rust-minidump in the testcrasher library" \footnote{Zastąpienie breakpad przez rust-minidump w blibliotece testcrasher}.

\section{Analiza biblioteki testcrasher}
\subsection{Cel biblioteki testcrasher}
Biblioteka dynamiczna testcrasher jest używana jako tester działania komponentu crashreporter w Mozilla Firefox.
Jej działanie skupia się na dwóch obszarach:
\begin{itemize}
    \item \textbf{Analiza zrzutu pamięci:} Za tą część odpowiada plik dumputils.cpp.
    \item \textbf{Wywoływanie awarii procesu:} Za tą część odpowiada plik nsTestCrasher.cpp. 
\end{itemize}
\subsection{Architektura biblioteki testcrasher przed migracją}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{figures/testcrasher.png}
\caption{architektura biblioteki testcrasher}
\label{fig:testcrasher-architecture}
\end{figure}

\section{Strategia migracji i wykorzystane narzędzia}
\subsection{Strategia migracji biblioteki testcrasher}
Przyjęta strategia migracji opiera się na stopniowym i iteracyjnym zastępowaniu kodu C++ kodem Rust, przy jednoczesnym zachowaniu w pełni kompatybilnego publicznego API.
Fundamentalnym założeniem jest, że z perspektywy klienta biblioteki, którym w tym przypadku są skrypty testujące, proces migracji jest całkowicie transparentny. Wymaga to utrzymania stabilnego interfejsu binarnego aplikacji (ABI) zgodnego z językiem C. Dzięki temu poszczególne funkcje, a docelowo całe moduły zaimplementowane w C++, mogą być zastępowane ich odpowiednikami w Rust, a następnie weryfikowane za pomocą istniejącego zestawu testów.
Proces migracji został zaplanowany w następujących, logicznie następujących po sobie etapach:
\begin{enumerate}
    \item \textbf{Konfiguracja hybrydowego procesu budowania:} Pierwszym krokiem jest modyfikacja systemu budowania Mozilli (moz.build) w celu umożliwienia współistnienia kodu C++ i Rust. Polega to na zdefiniowaniu reguł kompilacji dla nowego kodu Rust do postaci biblioteki statycznej (rust\_testcrasher.lib). Następnie, ta biblioteka statyczna jest dołączana do finalnej biblioteki dynamicznej (testcrasher.dll), a jej publiczne symbole są eksportowane w taki sposób, aby zachować zgodność z oryginalnym API.
    \item \textbf{Iteracyjna migracja logiki analitycznej (dumputils.cpp):} Proces właściwej migracji rozpoczyna się od komponentów analitycznych. Poszczególne funkcje odpowiedzialne za parsowanie i analizę plików minidump są reimplementowane w języku Rust, wykorzystując do tego celu bibliotekę `rust-minidump`. Po zaimplementowaniu każdej funkcji w Rust, jej oryginalna wersja w C++ jest usuwana, a nowa implementacja zostaje zintegrowana w procesie budowania.
    \item \textbf{Migracja logiki inicjującej awarie (nsTestCrasher.cpp):} Po pomyślnej weryfikacji poprawności działania modułu analitycznego, analogiczny proces jest stosowany do kodu odpowiedzialnego za inicjowanie stanów awaryjnych. Funkcje C++ są zastępowane przez ich odpowiedniki w Rust, które wykorzystują bibliotekę `sadness-generator`.
    \item \textbf{Finalizacja i czyszczenie konfiguracji:} Po zakończeniu migracji całości kodu funkcjonalnego do języka Rust, oryginalne pliki źródłowe C++ (`dumputils.cpp` oraz `nsTestCrasher.cpp`) są ostatecznie usuwane z drzewa projektu. Konfiguracja w pliku `moz.build` jest upraszczana, eliminując reguły dotyczące kompilacji C++ dla tej biblioteki.
\end{enumerate}
Dzięki takiemu podejściu, w dowolnym momencie procesu migracji biblioteka pozostaje w pełni funkcjonalna, zawierając mieszankę działającego kodu C++ i Rust.
\subsection{Wykorzytane narzędzia i technologie}
Do przeprowadzenia migracji wybranego fragmentu kodu użyto:
\begin{itemize}
    \item 
\end{itemize}